-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun isTrue(e) {
  Binop ("!=", e, Const(0))
}

fun toBinop() {
  fun (l, op, r) {Binop (op, l, r)}
}

var exp = memo $ eta syntax (
    x=decimal {Const (stringInt (x))}
  | x=lident  {Var (x)}
  | inbr[s("("), binopExp, s(")")]
  ),
  binopExp = memo $ eta expr ({
    [Left,  { [s ("!!") , fun (l, op, r) {Binop (op , isTrue(l), isTrue(r))}]
            }],
    [Left,  { [s ("&&") , fun (l, op, r) {Binop (op , isTrue(l), isTrue(r))}]
            }],
    [Nona,  { [s ("==") | s ("!=") | s ("<") | s ("<=") | s (">") | s (">=")  , 
              toBinop() ] }],
    [Left,  { [s ("+") | s ("-"), 
              toBinop()] }],
    [Left,  { [s ("*") | s ("/") | s ("%")  , 
              toBinop()] }] }
  , exp);

var command = memo $ eta syntax (
    kRead   x=inbr[s("("), lident   , s(")")]   {Read(x)}
  | kWrite  x=inbr[s("("), binopExp , s(")")]   {Write(x)}
  | kSkip                                       {Skip}
  | x=lident  s[":="] y=binopExp                {Assn(x, y)}
);

var stmt = memo $ eta syntax (
  x=command y=s[";"] z=stmt {Seq(x, z)}
| command
);

public parse = stmt;
