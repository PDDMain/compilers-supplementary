-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun isTrue(e) {
  Binop ("!=", e, Const(0))
}

var exp = memo $ eta syntax (
    x=decimal {Const (stringInt (x))}    
  | x=lident  {Var (x)}
  | inbr[s("("), binopExp, s(")")]
  ),
  binopExp = memo $ eta expr ({
    [Left,  { [s ("!!") , fun (l, op, r) {Binop ("!!" , isTrue(l), isTrue(r))}]
            }],
    [Left,  { [s ("&&") , fun (l, op, r) {Binop ("&&" , isTrue(l), isTrue(r))}]
            }],
    [Nona,  { [s ("==") , fun (l, op, r) {Binop ("==" , l, r)}],
              [s ("!=") , fun (l, op, r) {Binop ("!=" , l, r)}],
              [s ("<")  , fun (l, op, r) {Binop ("<"  , l, r)}],
              [s ("<=") , fun (l, op, r) {Binop ("<=" , l, r)}],
              [s (">")  , fun (l, op, r) {Binop (">"  , l, r)}],
              [s (">=") , fun (l, op, r) {Binop (">=" , l, r)}]
            }],
    [Left,  { [s ("+")  , fun (l, op, r) {Binop ("+"  , l, r)}],
              [s ("-")  , fun (l, op ,r) {Binop ("-"  , l, r)}]
            }],
    [Left,  { [s ("*")  , fun (l, op, r) {Binop ("*"  , l, r)}],
              [s ("/")  , fun (l, op, r) {Binop ("/"  , l, r)}],
              [s ("%")  , fun (l, op, r) {Binop ("%"  , l, r)}]
            }]
  }, exp);

var command = memo $ eta syntax (
    x=kRead   y=inbr[s("("), lident, s(")")]  {Read(y)}
  | x=kWrite  y=inbr[s("("), binopExp, s(")")]  {Write(y)}
  | x=kSkip                                   {Skip}
  | x=lident  y=s[":="] z=binopExp                 {Assn(x, z)}
);

var stmt = memo $ eta syntax (
  x=command y=s[";"] z=stmt {Seq(x, z)}
| command
);

public parse = stmt;
