-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun isTrue(e) {
  Binop ("!=", e, Const(0))
}

fun toBinop() {
  fun (l, op, r) {Binop (op, l, r)}
}

fun inRoundBr(f) {
  inbr(s("("), f, s(")"))
}

var exp = memo $ eta syntax (
    x=decimal {Const (stringInt (x))}
  | x=lident  {Var (x)}
  | inRoundBr[binopExp]
  ),
  binopExp = memo $ eta expr ({
    [Left,  { [s ("!!") , fun (l, op, r) {Binop (op , isTrue(l), isTrue(r))}]
            }],
    [Left,  { [s ("&&") , fun (l, op, r) {Binop (op , isTrue(l), isTrue(r))}]
            }],
    [Nona,  { [s ("==") | s ("!=") | s ("<") | s ("<=") | s (">") | s (">=")  , 
              toBinop() ] }],
    [Left,  { [s ("+") | s ("-"), 
              toBinop()] }],
    [Left,  { [s ("*") | s ("/") | s ("%")  , 
              toBinop()] }] }
  , exp);

var afterIf = memo $ eta syntax (
    x=binopExp kThen y=stmt                 {If(x, y, Skip)}
  | x=binopExp kThen y=stmt kElse z=stmt    {If(x, y, z)}
  | x=binopExp kThen y=stmt kElif z=afterIf {If(x, y, z)}
);

var command = memo $ eta syntax (
    kRead   x=inRoundBr[lident]             {Read(x)}
  | kWrite  x=inRoundBr[binopExp]           {Write(x)}
  | kSkip                                   {Skip}
  | x=lident  s[":="] y=binopExp            {Assn(x, y)}
  | kIf a=afterIf kFi                       {a}
  | kWhile x=binopExp kDo y=stmt kOd        {While(x, y)}
  | kDo x=stmt kWhile y=binopExp kOd        {DoWhile(x, y)}
  | kFor cmd1=command s[","] e=binopExp s[","] cmd2=command 
      kDo mainCmd=stmt kOd                  {Seq(cmd1, While(e, Seq(mainCmd, cmd2)))}
);

var stmt = memo $ eta syntax (
  x=command s[";"] y=stmt {Seq(x, y)}
| command
);

public parse = stmt;
